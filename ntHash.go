// Package nthash is a port of ntHash (https://github.com/bcgsc/ntHash) recursive hash function for DNA kmers.
//
// It was inspired by the Rust port by Luiz Irber (https://github.com/luizirber/nthash)
//
package nthash

import (
	"fmt"
	"math"
)

const (
	// MaxK is the maximum k-mer size permitted
	MaxK = math.MaxUint32

	// BufferSize is the size of te buffer used by the channel in the Hash method
	BufferSize = 128
)

// NTHi is the ntHash iterator
type NTHi struct {
	seq        *[]byte
	k          uint
	fh         uint64
	rh         uint64
	currentIdx uint
	maxIdx     uint
}

// NewHasher is the constructor function for the ntHash iterator
func NewHasher(seq *[]byte, k uint) (*NTHi, error) {
	seqLen := uint(len(*seq))
	if k > seqLen {
		return nil, fmt.Errorf("k size is greater than sequence length (%d vs %d)", k, seqLen)
	}
	if k > MaxK {
		return nil, fmt.Errorf("k size is greater than the maximum allowed k size (%d vs %d)", k, MaxK)
	}
	fh := ntf64((*seq)[0:k], 0, k)
	rh := ntr64((*seq)[0:k], 0, k)
	nthi := &NTHi{
		seq:        seq,
		k:          k,
		fh:         fh,
		rh:         rh,
		currentIdx: 0,
		maxIdx:     (seqLen - (k - 1)),
	}
	return nthi, nil
}

// Next returns the next canonical ntHash value from an ntHash iterator
func (nthi *NTHi) Next() uint64 {

	// end the iterator if we have got to the maximum index position TODO: this needs to be done in a better way.
	if nthi.currentIdx >= nthi.maxIdx {
		return 0
	}

	// roll the hash if index>0
	if nthi.currentIdx != 0 {
		prevBase := (*nthi.seq)[nthi.currentIdx-1]
		endBase := (*nthi.seq)[nthi.currentIdx+nthi.k-1]
		// alg 3. of ntHash paper
		nthi.fh = roL(nthi.fh, 1)
		nthi.fh ^= roL(hash(prevBase), nthi.k)
		nthi.fh ^= hash(endBase)
		nthi.rh = roR(nthi.rh, 1)
		nthi.rh ^= roR(rcHash(prevBase), 1)
		nthi.rh ^= roL(rcHash(endBase), nthi.k-1)
	}
	nthi.currentIdx++

	// return the canonical ntHash
	return nthi.getCanonical()
}

// Hash returns a channel to range over the canonical ntHash values of a sequence generated by the ntHash iterator
// if canonical true, the canonical k-mer is returned
func (nthi *NTHi) Hash(canonical bool) <-chan uint64 {
	hashChan := make(chan uint64, BufferSize)
	go func() {
		defer close(hashChan)
		// start the rolling hash
		for {
			// check that rolling can continue
			if nthi.currentIdx >= nthi.maxIdx {
				return
			}
			// start the hashing
			if nthi.currentIdx != 0 {
				prevBase := (*nthi.seq)[nthi.currentIdx-1]
				endBase := (*nthi.seq)[nthi.currentIdx+nthi.k-1]
				// alg 3. of ntHash paper
				nthi.fh = roL(nthi.fh, 1)
				nthi.fh ^= roL(hash(prevBase), nthi.k)
				nthi.fh ^= hash(endBase)
				nthi.rh = roR(nthi.rh, 1)
				nthi.rh ^= roR(rcHash(prevBase), 1)
				nthi.rh ^= roL(rcHash(endBase), nthi.k-1)
			}
			// calculate and return the canonical ntHash if requested
			if canonical {
				hashChan <- nthi.getCanonical()
			} else {
				hashChan <- nthi.fh
			}
			// increment the index
			nthi.currentIdx++
		}
	}()
	return hashChan
}

// getCanonical returns the canonical hash value currently held by the iterator
func (nthi *NTHi) getCanonical() uint64 {
	if nthi.rh < nthi.fh {
		return nthi.rh
	}
	return nthi.fh
}

// hash takes a base (byte) and returns a uint64 seed
func hash(base uint8) uint64 {
	switch base {
	case 'A':
		return 0x3c8bfbb395c60474
	case 'C':
		return 0x3193c18562a02b4c
	case 'G':
		return 0x20323ed082572324
	case 'T':
		return 0x295549f54be24456
	case 'N':
		return 0
	default:
		//panic(fmt.Errorf("non a/c/t/g/n base: %c", base))
		return 0
	}
}

// rcHash takes a base (byte) and returns a uint64 seed
func rcHash(base uint8) uint64 {
	switch base {
	case 'A':
		return 0x295549f54be24456
	case 'C':
		return 0x20323ed082572324
	case 'G':
		return 0x3193c18562a02b4c
	case 'T':
		return 0x3c8bfbb395c60474
	case 'N':
		return 0
	default:
		//panic(fmt.Errorf("non a/c/t/g/n base: %c", base))
		return 0
	}
}

// roL is a function to bit shift to the left by "n" positions
func roL(v uint64, n uint) uint64 {
	if (n & 63) == 0 {
		return v
	}
	return (v << n) | (v >> (64 - n))
}

// roR is a function to bit shift to the right by "n" positions
func roR(v uint64, n uint) uint64 {
	if (n & 63) == 0 {
		return v
	}
	return (v >> n) | (v << (64 - n))
}

// ntf64 generates the ntHash for the forward strand of the kmer
func ntf64(seq []byte, i, k uint) uint64 {
	var hv uint64
	for i < k {
		hv = roL(hv, 1)
		hv ^= hash(seq[i])
		i++
	}
	return hv
}

// ntr64 generates the ntHash for the reverse strand of the kmer
func ntr64(seq []byte, i, k uint) uint64 {
	var hv uint64
	for i < k {
		hv = roL(hv, 1)
		hv ^= rcHash(seq[k-1-i])
		i++
	}
	return hv
}

// ntc64 generates the canonical ntHash
func ntc64(seq []byte, i, k uint) uint64 {
	fh := ntf64(seq, i, k)
	rh := ntr64(seq, i, k)
	if rh < fh {
		return rh
	}
	return fh
}

// nthash returns the canonical ntHash for each k-mer in a sequence
// it does not use the rolling hash properties of ntHash
func nthash(seq []byte, k int) []uint64 {
	hvs := make([]uint64, (len(seq) - (k - 1)))
	for i := 0; i <= (len(seq) - k); i++ {
		hvs[i] = ntc64(seq[i:i+k], 0, uint(k))
	}
	return hvs
}
